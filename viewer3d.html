<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MiDaS 3D Depth Viewer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", Arial, sans-serif;
        background: #1a1a2e;
        color: #fff;
        overflow: hidden;
      }
      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      /* Preview panels */
      #previews {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 100;
      }
      #previews.hidden {
        display: none;
      }
      .preview-panel {
        background: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
        padding: 8px;
        backdrop-filter: blur(10px);
      }
      .preview-panel h4 {
        font-size: 11px;
        color: #888;
        margin-bottom: 5px;
        text-transform: uppercase;
      }
      .preview-panel canvas,
      .preview-panel img {
        width: 200px;
        height: auto;
        border-radius: 4px;
        display: block;
      }

      /* Loading overlay */
      #loading {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(26, 26, 46, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      #loading.hidden {
        display: none;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #333;
        border-top-color: #00d4ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      #loading-text {
        color: #00d4ff;
        font-size: 16px;
      }

      /* Drop zone */
      #dropzone {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        height: 250px;
        border: 3px dashed #444;
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 500;
      }
      #dropzone:hover,
      #dropzone.dragover {
        border-color: #00d4ff;
        background: rgba(0, 212, 255, 0.1);
      }
      #dropzone.hidden {
        display: none;
      }
      #dropzone h2 {
        color: #666;
        margin-bottom: 10px;
      }
      #dropzone p {
        color: #444;
        font-size: 14px;
      }
      #dropzone input {
        display: none;
      }

      /* Demo button */
      .demo-button {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
        padding: 12px 24px;
        background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
        border: none;
        border-radius: 25px;
        color: white;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        animation: pulse 2s infinite;
      }
      .demo-button:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
      }
      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
        }
        50% {
          box-shadow: 0 4px 25px rgba(255, 107, 53, 0.7);
        }
      }
      .demo-preview {
        margin-top: 15px;
        width: 120px;
        height: auto;
        border-radius: 8px;
        opacity: 0.8;
        transition: all 0.3s ease;
        border: 2px solid #444;
      }
      .demo-preview:hover {
        opacity: 1;
        border-color: #ff6b35;
      }

      /* Info bar */
      #info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 12px;
        color: #888;
      }

      /* Status message */
      #status {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 212, 255, 0.2);
        border: 1px solid #00d4ff;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        color: #00d4ff;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      }
      #status.show {
        opacity: 1;
      }
      #status.error {
        background: rgba(255, 107, 107, 0.2);
        border-color: #ff6b6b;
        color: #ff6b6b;
      }

      /* dat.GUI customization */
      .dg.ac {
        z-index: 1000 !important;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <button id="demoBtn" class="demo-button">Essaie avec "La Suze" !</button>

    <div id="dropzone">
      <h2>üìÅ Drop Image Here</h2>
      <p>or click to browse</p>
      <input type="file" id="fileInput" accept="image/*" />
    </div>

    <div id="previews" class="hidden">
      <div class="preview-panel">
        <h4>Original</h4>
        <img id="originalPreview" />
      </div>
      <div class="preview-panel">
        <h4>Depth Map</h4>
        <canvas id="depthPreview"></canvas>
      </div>
    </div>

    <div id="loading" class="hidden">
      <div class="spinner"></div>
      <div id="loading-text">Processing...</div>
    </div>

    <div id="status"></div>

    <div id="info">
      üñ±Ô∏è Left-click + drag to rotate | Scroll to zoom | Right-click + drag to
      pan
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // State
      let scene, camera, renderer, controls, mesh;
      let imageTexture, depthDataRaw, depthData, originalImage;
      let planeGeometry;
      let gui;

      // Debouncing state
      let isProcessing = false;
      let debounceTimer = null;
      const DEBOUNCE_DELAY = 50; // ms

      // Parameters controlled by dat.GUI
      const params = {
        // Real-time depth adjustments (client-side)
        depthScale: 1.0,
        smoothing: 0,
        invert: false,

        // 3D view
        meshDepth: 0.5,
        resolution: 128,
        wireframe: false,

        // Actions
        loadImage: () => document.getElementById("fileInput").click(),
        resetCamera: () => resetCamera(),
      };

      // Initialize
      init();

      function init() {
        setupScene();
        setupGUI();
        setupDropzone();
        animate();
      }

      function setupScene() {
        const container = document.getElementById("container");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 1.5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 10;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        window.addEventListener("resize", onWindowResize);
      }

      function setupGUI() {
        gui = new dat.GUI({ width: 300 });

        // Image folder
        const imageFolder = gui.addFolder("üìÅ Image");
        imageFolder.add(params, "loadImage").name("Load Image");
        imageFolder.open();

        // Depth adjustments folder (real-time)
        const depthFolder = gui.addFolder("üéØ Depth Adjustments (Real-time)");
        depthFolder
          .add(params, "depthScale", 0.1, 3.0, 0.01)
          .name("Depth Scale")
          .onChange(debouncedApplyDepth);
        depthFolder
          .add(params, "smoothing", 0, 20, 1)
          .name("Smoothing")
          .onChange(debouncedApplyDepth);
        depthFolder
          .add(params, "invert")
          .name("Invert Depth")
          .onChange(debouncedApplyDepth);
        depthFolder.open();

        // 3D View folder
        const viewFolder = gui.addFolder("üèîÔ∏è 3D View");
        viewFolder
          .add(params, "meshDepth", 0.1, 2.0, 0.05)
          .name("Mesh Depth")
          .onChange(debouncedUpdateMeshDepth);
        viewFolder
          .add(params, "resolution", 32, 256, 16)
          .name("Resolution")
          .onChange(debouncedRecreateMesh);
        viewFolder
          .add(params, "wireframe")
          .name("Wireframe")
          .onChange(toggleWireframe);
        viewFolder.add(params, "resetCamera").name("üîÑ Reset Camera");
        viewFolder.open();
      }

      function setupDropzone() {
        const dropzone = document.getElementById("dropzone");
        const fileInput = document.getElementById("fileInput");
        const demoBtn = document.getElementById("demoBtn");

        dropzone.addEventListener("click", (e) => {
          // Don't trigger file input if clicking on demo button or preview
          if (e.target.id === "demoBtn" || e.target.id === "demoPreview")
            return;
          fileInput.click();
        });

        demoBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          loadDemo();
        });

        dropzone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropzone.classList.add("dragover");
        });

        dropzone.addEventListener("dragleave", () => {
          dropzone.classList.remove("dragover");
        });

        dropzone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropzone.classList.remove("dragover");
          const file = e.dataTransfer.files[0];
          if (file && file.type.startsWith("image/")) {
            loadImageFile(file);
          }
        });

        fileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (file) {
            loadImageFile(file);
          }
        });
      }

      function loadImageFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          originalImage = new Image();
          originalImage.onload = () => {
            // Show original preview
            document.getElementById("originalPreview").src = e.target.result;
            document.getElementById("previews").classList.remove("hidden");
            document.getElementById("dropzone").classList.add("hidden");

            showStatus('Image loaded! Click "Generate Depth" to process.');

            // Auto-generate depth map
            processImage();
          };
          originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      async function loadDemo() {
        showStatus("Loading demo image...");
        try {
          const response = await fetch(`${window.location.origin}/demo-image`);
          if (!response.ok) throw new Error("Demo image not found");

          const blob = await response.blob();
          const file = new File([blob], "lasuze.jpeg", { type: "image/jpeg" });
          loadImageFile(file);
        } catch (error) {
          showStatus("Error loading demo: " + error.message, true);
        }
      }

      async function processImage() {
        if (!originalImage) {
          showStatus("Please load an image first", true);
          return;
        }

        showLoading(true, "Generating depth map with MiDaS...");

        try {
          // Create canvas to get image data
          const canvas = document.createElement("canvas");
          canvas.width = originalImage.width;
          canvas.height = originalImage.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(originalImage, 0, 0);
          const imageDataUrl = canvas.toDataURL("image/png");

          // Send to server for raw depth processing (no adjustments)
          const response = await fetch(`${window.location.origin}/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              image: imageDataUrl,
            }),
          });

          if (!response.ok) throw new Error("Server error");

          const data = await response.json();
          // Store raw depth data
          depthDataRaw = data.depth;

          // Apply initial adjustments
          applyDepthAdjustments();

          showLoading(false);
          showStatus("Depth map ready! Adjust sliders in real-time.");
        } catch (error) {
          showLoading(false);
          showStatus("Error: " + error.message, true);
        }
      }

      // Debounced wrapper for depth adjustments
      function debouncedApplyDepth() {
        // Clear any pending timer
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }

        // If currently processing, schedule for after
        if (isProcessing) {
          debounceTimer = setTimeout(debouncedApplyDepth, DEBOUNCE_DELAY);
          return;
        }

        // Schedule the actual processing
        debounceTimer = setTimeout(() => {
          applyDepthAdjustments();
        }, DEBOUNCE_DELAY);
      }

      // Real-time depth adjustments (client-side)
      function applyDepthAdjustments() {
        if (!depthDataRaw || isProcessing) return;

        isProcessing = true;

        const raw = depthDataRaw.data;
        const width = depthDataRaw.width;
        const height = depthDataRaw.height;

        // Create processed depth array
        let processed = new Float32Array(raw.length);

        // Copy and apply scale + invert
        for (let i = 0; i < raw.length; i++) {
          let val = raw[i] * params.depthScale;
          if (params.invert) val = params.depthScale - val;
          processed[i] = Math.max(0, Math.min(1, val));
        }

        // Apply smoothing (box blur for performance)
        if (params.smoothing > 0) {
          processed = applyBlur(processed, width, height, params.smoothing);
        }

        // Update depthData
        depthData = {
          width: width,
          height: height,
          data: Array.from(processed),
        };

        // Update preview and mesh
        updateDepthPreview();
        if (mesh) {
          applyDepthToGeometry();
        } else {
          createMesh();
        }

        // Mark processing as complete
        isProcessing = false;
      }

      // Fast box blur for real-time smoothing
      function applyBlur(data, width, height, radius) {
        const result = new Float32Array(data.length);
        const size = radius * 2 + 1;
        const div = size * size;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let sum = 0;
            let count = 0;

            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                const ny = y + dy;

                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  sum += data[ny * width + nx];
                  count++;
                }
              }
            }

            result[y * width + x] = sum / count;
          }
        }

        return result;
      }

      function updateDepthPreview() {
        if (!depthData) return;

        const canvas = document.getElementById("depthPreview");
        canvas.width = depthData.width;
        canvas.height = depthData.height;
        const ctx = canvas.getContext("2d");

        const imageData = ctx.createImageData(
          depthData.width,
          depthData.height
        );
        const data = depthData.data;

        for (let i = 0; i < data.length; i++) {
          const val = Math.floor(data[i] * 255);
          imageData.data[i * 4] = val;
          imageData.data[i * 4 + 1] = val;
          imageData.data[i * 4 + 2] = val;
          imageData.data[i * 4 + 3] = 255;
        }

        ctx.putImageData(imageData, 0, 0);
      }

      function createMesh() {
        if (!depthData || !originalImage) return;

        if (mesh) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
        }

        const width = depthData.width;
        const height = depthData.height;
        const aspect = width / height;

        const segments = params.resolution;
        planeGeometry = new THREE.PlaneGeometry(
          aspect,
          1,
          segments,
          Math.floor(segments / aspect)
        );

        imageTexture = new THREE.Texture(originalImage);
        imageTexture.needsUpdate = true;
        imageTexture.colorSpace = THREE.SRGBColorSpace;

        applyDepthToGeometry();

        const material = new THREE.MeshStandardMaterial({
          map: imageTexture,
          side: THREE.DoubleSide,
          wireframe: params.wireframe,
          flatShading: false,
        });

        mesh = new THREE.Mesh(planeGeometry, material);
        scene.add(mesh);
      }

      function applyDepthToGeometry() {
        if (!planeGeometry || !depthData) return;

        const positions = planeGeometry.attributes.position;
        const width = depthData.width;
        const height = depthData.height;
        const depth = depthData.data;
        const aspect = width / height;

        for (let i = 0; i < positions.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);

          const u = x / aspect + 0.5;
          const v = y + 0.5;

          const px = Math.floor(u * (width - 1));
          const py = Math.floor((1 - v) * (height - 1));
          const idx = py * width + px;

          const depthValue = depth[idx] || 0;
          positions.setZ(i, depthValue * params.meshDepth);
        }

        planeGeometry.attributes.position.needsUpdate = true;
        planeGeometry.computeVertexNormals();
      }

      // Debounced mesh depth update
      let meshDepthTimer = null;
      function debouncedUpdateMeshDepth() {
        if (meshDepthTimer) clearTimeout(meshDepthTimer);
        meshDepthTimer = setTimeout(updateMeshDepth, DEBOUNCE_DELAY);
      }

      function updateMeshDepth() {
        if (planeGeometry && depthData) {
          applyDepthToGeometry();
        }
      }

      // Debounced mesh recreation
      let recreateMeshTimer = null;
      function debouncedRecreateMesh() {
        if (recreateMeshTimer) clearTimeout(recreateMeshTimer);
        recreateMeshTimer = setTimeout(recreateMesh, 100); // Longer delay for heavy operation
      }

      function recreateMesh() {
        createMesh();
      }

      function toggleWireframe() {
        if (mesh) {
          mesh.material.wireframe = params.wireframe;
        }
      }

      function resetCamera() {
        camera.position.set(0, 0, 1.5);
        controls.target.set(0, 0, 0);
        controls.update();
      }

      function showLoading(show, text = "Processing...") {
        const loading = document.getElementById("loading");
        document.getElementById("loading-text").textContent = text;
        if (show) {
          loading.classList.remove("hidden");
        } else {
          loading.classList.add("hidden");
        }
      }

      function showStatus(message, isError = false) {
        const status = document.getElementById("status");
        status.textContent = message;
        status.classList.toggle("error", isError);
        status.classList.add("show");

        setTimeout(() => {
          status.classList.remove("show");
        }, 4000);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
